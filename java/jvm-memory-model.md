# JVM 内存模型

## JVM内存结构

JVM内存结构是指Java虚拟机定义的运行时数据区域，主要包括以下几个部分：

### 1. 程序计数器（Program Counter Register）

- 当前线程所执行的字节码的行号指示器
- 线程私有，每个线程都有自己的程序计数器
- 唯一一个在JVM规范中没有规定任何OutOfMemoryError情况的区域

### 2. Java虚拟机栈（Java Virtual Machine Stack）

- 线程私有，生命周期与线程相同
- 每个方法在执行时会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息
- 局部变量表存放了编译期可知的各种基本数据类型、对象引用和returnAddress类型
- 可能抛出的异常：StackOverflowError和OutOfMemoryError

### 3. 本地方法栈（Native Method Stack）

- 与Java虚拟机栈类似，但为本地（Native）方法服务
- 线程私有
- 可能抛出的异常：StackOverflowError和OutOfMemoryError

### 4. Java堆（Java Heap）

- 所有线程共享的内存区域
- 存放对象实例和数组
- 垃圾收集器管理的主要区域，也称为「GC堆」
- 可以物理上不连续，但逻辑上应该连续
- 可能抛出的异常：OutOfMemoryError

### 5. 方法区（Method Area）

- 所有线程共享的内存区域
- 存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据
- JDK 8之前，方法区也被称为「永久代」（PermGen）
- JDK 8及以后，方法区的实现被称为「元空间」（Metaspace），使用本地内存
- 可能抛出的异常：OutOfMemoryError

### 6. 运行时常量池（Runtime Constant Pool）

- 方法区的一部分
- 存放编译期生成的各种字面量和符号引用
- 具有动态性，运行期间也可以将新的常量放入池中
- 可能抛出的异常：OutOfMemoryError

### 7. 直接内存（Direct Memory）

- 不是JVM运行时数据区的一部分，但被频繁使用
- NIO的DirectByteBuffer对象使用直接内存，可以显著提高性能
- 不受Java堆大小的限制，但受本机总内存的限制
- 可能抛出的异常：OutOfMemoryError

## Java内存模型（JMM）

Java内存模型（Java Memory Model，JMM）是一种抽象的概念，它定义了线程之间如何通过内存进行交互。JMM的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。

### 主内存与工作内存

- **主内存**：所有线程共享的内存区域，存储所有变量的主副本
- **工作内存**：每个线程私有的内存区域，存储该线程使用到的变量的副本

线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，不能直接读写主内存中的变量。不同线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递需要通过主内存来完成。

### 内存间交互操作

JMM定义了8种操作来完成主内存和工作内存的交互：

1. **lock（锁定）**：作用于主内存的变量，把一个变量标识为一条线程独占的状态
2. **unlock（解锁）**：作用于主内存的变量，把一个处于锁定状态的变量释放出来
3. **read（读取）**：作用于主内存的变量，把一个变量的值从主内存传输到线程的工作内存中
4. **load（载入）**：作用于工作内存的变量，把read操作从主内存中得到的变量值放入工作内存的变量副本中
5. **use（使用）**：作用于工作内存的变量，把工作内存中的一个变量的值传递给执行引擎
6. **assign（赋值）**：作用于工作内存的变量，把一个从执行引擎接收到的值赋给工作内存的变量
7. **store（存储）**：作用于工作内存的变量，把工作内存中一个变量的值传送到主内存中
8. **write（写入）**：作用于主内存的变量，把store操作从工作内存中得到的变量的值放入主内存的变量中

### 内存模型的三大特性

1. **原子性**：一个操作是不可中断的，要么全部执行成功，要么全部执行失败
   - 基本数据类型的读写操作是原子性的（long和double的非volatile变量除外）
   - synchronized和Lock可以保证更大范围操作的原子性

2. **可见性**：当一个线程修改了共享变量的值，其他线程能够立即得知这个修改
   - volatile关键字可以保证可见性
   - synchronized和Lock也能保证可见性
   - final也能保证可见性，被final修饰的字段在构造器中一旦初始化完成，其他线程就能看见final字段的值

3. **有序性**：程序执行的顺序按照代码的先后顺序执行
   - Java内存模型允许编译器和处理器对指令进行重排序，但重排序过程不会影响单线程程序的执行结果
   - volatile关键字禁止指令重排序
   - synchronized和Lock保证同一时刻只有一个线程执行同步代码，相当于保证了有序性

### happens-before原则

happens-before是Java内存模型中定义的两项操作之间的偏序关系，如果操作A happens-before操作B，那么操作A的结果对操作B是可见的。主要规则包括：

1. **程序顺序规则**：一个线程中的每个操作，happens-before于该线程中的任意后续操作
2. **监视器锁规则**：对一个锁的解锁，happens-before于随后对这个锁的加锁
3. **volatile变量规则**：对一个volatile域的写，happens-before于任意后续对这个volatile域的读
4. **传递性**：如果A happens-before B，且B happens-before C，那么A happens-before C
5. **线程启动规则**：Thread对象的start()方法happens-before于该线程的每一个动作
6. **线程终止规则**：线程中的所有操作都happens-before于对此线程的终止检测（通过Thread.join()方法检测、Thread.isAlive()方法检测）
7. **线程中断规则**：对线程interrupt()方法的调用happens-before于被中断线程的代码检测到中断事件的发生
8. **对象终结规则**：一个对象的初始化完成happens-before于它的finalize()方法的开始

### volatile关键字

volatile是Java提供的一种轻量级的同步机制，它保证了变量的可见性和有序性，但不保证原子性。

- **可见性**：当一个线程修改了volatile变量的值，该值会立即被刷新到主内存中，其他线程读取该变量时会从主内存中读取最新值
- **有序性**：禁止指令重排序优化，确保代码的执行顺序与程序的顺序一致

适用场景：
- 对变量的写操作不依赖于当前值（如递增操作就不适合）
- 该变量不会与其他状态变量一起纳入不变性条件中
- 访问变量时不需要加锁

### synchronized关键字

synchronized是Java提供的一种重量级的同步机制，它可以保证原子性、可见性和有序性。

- 可以修饰实例方法、静态方法和代码块
- 实例方法锁定的是当前实例对象
- 静态方法锁定的是当前类的Class对象
- 代码块可以锁定指定的对象

### final关键字

final关键字在Java内存模型中也有特殊的语义：

- 被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把this引用传递出去，那么其他线程就能看见final字段的值
- 这是因为final域的赋值操作会在构造函数return之前插入一个StoreStore屏障，确保final域的写入操作不会被重排序到构造函数之外