# JVM (Java Virtual Machine)

JVM（Java虚拟机）是Java平台的核心组件，它是一个虚拟的计算机，提供可以执行Java字节码的运行时环境。JVM是实现Java平台无关性的关键，它使得Java程序可以在任何支持JVM的设备上运行，而无需重新编译。

## JVM架构

JVM主要由以下几个部分组成：

1. **类加载子系统**：负责加载、链接和初始化类文件
2. **运行时数据区**：包括方法区、堆、Java栈、本地方法栈和程序计数器
3. **执行引擎**：包括即时编译器（JIT）和垃圾回收器（GC）
4. **本地方法接口**：提供与本地方法库交互的接口

```
┌─────────────────────────────────────────────────────────┐
│                     JVM架构                             │
├─────────────┬─────────────────────────┬────────────────┤
│ 类加载子系统  │      运行时数据区         │    执行引擎     │
│             │                         │                │
│ 加载 → 链接  │ ┌─────┐ ┌───┐ ┌──────┐  │  解释器        │
│      ↓      │ │方法区│ │堆 │ │Java栈│   │                │
│    初始化    │ └─────┘ └───┘ └──────┘ │  JIT编译器     │
│             │ ┌──────────┐ ┌──────┐  │                │
│             │ │程序计数器  │ │本地栈│  │  垃圾回收器     │
│             │ └──────────┘ └──────┘   │                │
├─────────────┴─────────────────────────┴────────────────┤
│                   本地方法接口                          │
├─────────────────────────────────────────────────────────┤
│                   本地方法库                            │
└─────────────────────────────────────────────────────────┘
```

## JVM相关知识

* [JVM 内存模型](./jvm-memory-model.md) - 介绍JVM内存结构和Java内存模型(JMM)
* [JVM 内存分配](./jvm-memory-allocation.md) - 详解JVM中的内存分配策略和机制
* [JVM 垃圾回收](./jvm-gc.md) - 垃圾回收算法、垃圾收集器及其工作原理
* [JVM 类加载机制](./jvm-class-loading.md) - 类的加载、链接和初始化过程
* [JVM 类加载器](./jvm-class-loader.md) - 引导类加载器、扩展类加载器和应用类加载器

## JVM调优

### 常用JVM参数

* `-Xms`: 设置JVM初始堆大小
* `-Xmx`: 设置JVM最大堆大小
* `-Xss`: 设置线程栈大小
* `-XX:NewRatio`: 设置年轻代与老年代的比例
* `-XX:SurvivorRatio`: 设置Eden区与Survivor区的比例
* `-XX:+UseG1GC`: 使用G1垃圾收集器
* `-XX:+UseConcMarkSweepGC`: 使用CMS垃圾收集器
* `-XX:+PrintGCDetails`: 打印详细的GC日志

### 性能监控工具

* `jps`: 显示当前所有Java进程的PID
* `jstat`: 监视JVM各种运行状态信息
* `jmap`: 生成堆转储快照
* `jstack`: 生成线程快照
* `jinfo`: 实时查看和调整JVM配置参数
* `jconsole`: 图形化监控工具
* `jvisualvm`: 多合一故障诊断和性能监控工具
* `Arthas`: 阿里开源的Java诊断工具

### 调优建议

1. 根据应用特点选择合适的垃圾收集器
2. 合理设置堆内存大小，避免内存不足或过大
3. 优化代码，减少对象创建和临时对象
4. 及时关闭不再使用的资源
5. 使用工具监控GC情况，分析性能瓶颈
6. 考虑使用本地缓存减少对象创建
7. 调整JIT编译阈值优化热点代码

